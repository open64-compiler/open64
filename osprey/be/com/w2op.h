/*
 * Copyright (C) 2021 Xcalibyte (Shenzhen) Limited.
 */

/*

  Copyright (C) 2000, 2001 Silicon Graphics, Inc.  All Rights Reserved.

  This program is free software; you can redistribute it and/or modify it
  under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it would be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

  Further, this software is distributed without any warranty that it is
  free of the rightful claim of any third person regarding infringement 
  or the like.  Any license provided herein, whether implied or 
  otherwise, applies only to this software file.  Patent licenses, if 
  any, provided herein do not apply to combinations of this program with 
  other software, or any other product whatsoever.  

  You should have received a copy of the GNU General Public License along
  with this program; if not, write the Free Software Foundation, Inc., 59
  Temple Place - Suite 330, Boston MA 02111-1307, USA.

  Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pky,
  Mountain View, CA 94043, or:

  http://www.sgi.com

  For further information regarding this notice, see:

  http://oss.sgi.com/projects/GenInfo/NoticeExplan

*/


#ifndef	w2op_INCLUDED
#define	w2op_INCLUDED

#include "topcode.h"

#ifdef __cplusplus
extern "C" {
#endif

/* Given a WHIRL opcode, return the corresponding TOP.
 * This will only return machine ops, 
 * else TOP_UNDEFINED if not an exact correspondence.
 */
extern TOP OPCODE_To_TOP (OPCODE opcode);

/* Given a WHIRL node, return the corresponding TOP. 
 * This will only return machine ops, 
 * else TOP_UNDEFINED if not an exact correspondence.
 * (this handles more cases than OPCODE_To_TOP, cause it can look at kids).
 */
extern TOP WHIRL_To_TOP (WN *wn);

/* return whether MPY, DIV, or REM will be translated into shifts and adds */
extern BOOL Can_Do_Fast_Multiply (TYPE_ID mtype, INT64 val);
extern BOOL Can_Do_Fast_Divide (TYPE_ID mtype, INT64 val);
extern BOOL Can_Do_Fast_Remainder (TYPE_ID mtype, INT64 val);

/* When trying to convert a multiply or divide operation into a series
 * of shifts/adds/subtracts, there is some limit (cycles? ops?) at
 * which the conversion is not profitable.  Return that limit.
 */
extern INT Multiply_Limit ( BOOL is_64bit, INT64 val);
extern INT Divide_Limit ( BOOL is_64bit);

/* Return whether or not the immediate specified by <val> would be a valid
 * operand of the machine instruction generated by the whirl operator
 * <opr> with the immediate as the <whichkid> whirl operand.
 * The datatype of the operator is specified by <dtype> and if the
 * operation is an STID, <stid_st> specifies the symbol being stored to.
 */
extern BOOL Can_Be_Immediate(OPERATOR opr,
			     INT64 val,
			     TYPE_ID dtype,
			     INT whichkid,
			     ST *stid_st);

#ifdef TARG_NVISA
/* Return whether the float immediate of type <mtype> would be a valid
 * operand of machine instruction. This can be decided independently of
 * the operator or location of constant in an instruction or value of 
 * the constant
 */
extern BOOL Can_Be_Float_Immediate(TYPE_ID mtype);
#endif

/* determine speculative execution taking into account eagerness level
 *
 */
extern BOOL TOP_Can_Be_Speculative (TOP opcode);
extern BOOL WN_Can_Be_Speculative (WN *wn, struct ALIAS_MANAGER *alias);
extern BOOL WN_Expr_Can_Be_Speculative (WN *wn, struct ALIAS_MANAGER *alias);
extern BOOL OPCODE_Can_Be_Speculative(OPCODE opcode);

#ifdef TARG_UWASM
typedef struct mtype_to_cvt_top
{
  TYPE_ID src_mtype;
  TYPE_ID res_mtype;
  UINT8   comb_top;  // require combined TOPs to do convert
  TOP     top;

  BOOL Top_avail() { return (top != TOP_UNDEFINED || comb_top == TRUE); }

} Mtype_To_Cvt_Top;

extern Mtype_To_Cvt_Top &Get_Cvt_Top(TYPE_ID src_mtype, TYPE_ID res_mtype);
extern BOOL Req_Sign_Ext(TYPE_ID src_mtype, TYPE_ID res_mtype);
extern BOOL Req_Unsigned_Ext(TYPE_ID src_mtype, TYPE_ID res_mtype);
extern BOOL Req_Truncate(TYPE_ID src_mtype, TYPE_ID res_mtype);

#endif
#ifdef __cplusplus
}
#endif
#endif /* w2op_INCLUDED */
